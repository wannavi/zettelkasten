---
title: 22-12-26 빅 오 감잡아보기
date: 2022-12-26
tags:
 - 태그 1
---

## 메모

빅오 표현에 대해서는 대부분 간단하게나마 이해를 하고 있을 것이라 생각한다.

나는 개인적으로 입력값(n)이 무한대로 갈때 함수의 실행 시간의 근사라는 정의를 혼자 사용한다. 현재 우리가 일반적으로 말하는 빅오 표현법은 빅세타와 혼용되고 있기 때문에 위와 같은 방식으로 마음대로 정의해서 이해해도 좋을 듯 하다.

### 어떤 자료구조나 알고리즘에 대한 어림잡기가 가능해야 한다.

사실 자료구조와 알고리즘을 배우는 가장 큰 이유 중 하나라고 생각한다. 문제를 해결하는 방식을 나열해보고 시간 복잡도, 공간 복잡도를 어림잡아 더 효율적인 방법을 찾는 것이 핵심 아닐까?

- O(1): 입력값이 아무리 커도 실행 시간은 일정한 경우
	- "해시 테이블의 조회 및 삽입"이 이에 해당한다.
- O(log n): 로그는 완만하게 증가하므로 입력값에 그나마 덜 영향받는다고 생각하자.
	- "이진 검색"이 이에 해당한다. 
	- DB 에서 인덱스를 탄다면 이 경우가 아닐까? B-Tree는 삽입 삭제 조회가 O(log n) 에 해당한다.
- O(n) : 선형 시간 알고리즘이다. 
	- "정렬되지 않은 리스트에서 최댓값 또는 최솟값을 찾는 경우"가 이에 해당한다.
	- 선형적으로 탐색하는 경우 (하나씩 다 체크)
- O(nlog n): 일반적으로 사용하는 효율좋은 정렬 알고리즘이 이에 해당한다.
	- 여담이지만 이보다 빠른 정렬 알고리즘은 존재할 수 없다는 것이 증명되었다고 한다.
- O(n^2): 버블 정렬과 같은 비효율적인 정렬 알고리즘이 이에 해당한다.
	- 부분을 점점 키워가며 전체를 돌아봐야하는 경우라고 생각하면 된다.
- O(2^n): 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다.
	- 시간 복잡도가 이 근처라면 잘못 접근하고 있는건 아닌지 생각해볼 필요가 있다.
- O(n!): 외판원 문제(TSP)를 브루트 포스로 풀이할 떄 이에 해당한다.

## 참고문헌


## 연결문서

