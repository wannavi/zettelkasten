---
title: 23-01-06 NestJS와 타입스크립트의 한계
date: 2023-01-06
tags:
 - DI
 - NestJS
 - TypeScript
---

## 인터페이스와 구현체의 분리

자바 스프링 개발을 하다보면 당연하게도 인터페이스를 두고 `xxxImpl`과 같은 방식으로 `xxx` 인터페이스의 구현체를 만드는 방식이 당연하다고 여겨질 것이다. 이와 같은 방식의 가장 큰 장점은 `SOLID` 원칙을 아주 잘 준수할 수 있게 코드를 만들어주며 다형성을 아주 잘 이용할 수 있는 구조를 만들어준다는 것이다.

하지만 **NestJS에서는 이러한 방식을 잘 적용시키기 어렵다**.

## 인터페이스 레벨의 인젝션

스프링의 IoC 컨테이너를 이용해봤으면 알겠지만, 실제 구현체에 명시되어 있는 멤버 변수들의 타입은은 일반적으로 `인터페이스`이다. 말 그대로 다형성을 십분 활용할 수 있는 형태로 구현체에 의존하지 않는다는 DIP 원칙을 잘 준수할 수 있게 해주는 것이다. 그리고 실제 사용되는 구현체는 `SpringConfig` 등을 통해 해결하여 코드 레벨에서는 신경쓸 필요가 없게 만들어준다.

## 타입스크립트에서의 인터페이스는...

아쉽게도 실제 코드의 실행단계에서는 아무런 역할을 하지 못한다. 따라서 컨테이너에 주입한다는 개념 자체가 성립되지 않는다. (정확히는 `providers`로 제공할 수 없다. 관련 답변은 [해당 이슈](https://github.com/nestjs/nest/issues/43) 확인)

그렇다면 이러한 문제점을 코드레벨에서 어떻게 해결하면 좋을까?

## 먼저 Nest에서 DI를 어떻게 처리하는지 살펴보자.

> NestJS에서 다루는 클래스들은 `provider`로 다뤄지고 dependency로 injection 된다.

일반적으로 NestJS에서 `Provider`를 사용할 때 다음과 같이 작성할 것이다. 

```ts
@Module({
	controllers: [CatsController],
	providers: [CatsService]
})
```

하지만 실제로는 다음 신택스의 편리한 버전(?)일 뿐이다.

```ts
providers: [
	{
		provide: CatsService,
		useClass: CatsService,
	}
]
```

간단하게 설명하자면 provide로 제공된 `CatsService` 토큰을 useClass로 제공된 구현체인 `CatsService` 에 연결한다는 뜻이다. (`provide`는 컨테이너에 저장하는 키값이라고 생각하면 좋을 것 같다.)

providers에 대한 더 자세한 설명은 생략하도록 하고, 여기서 얻을 수 있는 아이디어는 `provide` 로 추상 클래스를 제공하고 `useClass`로 그 구현체를 제공하는 방식이면 스프링에서의 인터페이스와 비슷한 방식의 동작을 만들어 낼 수 있을 것이라는 것이다.

> TS에서는 abstract라는 키워드를 제공하여 추상 클래스를 제공한다. 여기서 주목할 interface와의 차이는 런타임에 존재한다는 점이다. (위에서 문제가 되었던 점..)

## 실제 구현을 해보자.

내가 작성한 다음 레포지토리를 살펴보도록 하자!..

## 참고문헌

- [NestJS Issues/43](https://github.com/nestjs/nest/issues/43)

## 연결문서

