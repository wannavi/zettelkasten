---
title: Reverse Proxy, 그리고 CGI 게이트웨이
date: 2022-10-02
---

# 주제 : #네트워크 #서버

## ✏️ 메모

왜 Node.js 서버 배포 시 `nginx`가 필요한지에 대한 문서를 읽고 있었는데 아래와 같은 문장을 읽었다. 아래 내용을 이해하기 위해 정리를 해보는 시간을 가져보도록 하자.

> `PHP`나 `Python`과 같은 언어를 사용하려면 해당 언어를 지원하는 웹 서버나 해당 언어와 작동하는 일종의 CGI 게이트웨이를 설정할 수 있는 기능이 필요했다. 하지만 Node.js 를 사용하면 HTTP 요청을 직접 처리하는 애플리케이션을 작성할 수 있다. 결과적으로 여러 도메인에 대한 요청을 처리하는 응용 프로그램을 작성하고 여러 포트(예: HTTP 및 HTTPS)에서 수신 대기한 다음 이러한 응용 프로그램을 인터넷에 직접 노출하여 요청을 처리하려는 유혹이 있습니다.

## CGI 개념부터 정리해보도록 하자.

먼저 Web Server의 가장 기본적인 형태에 대해 이야기를 해보자. 웹 서버는 Apache, Nginx 등이 존재하는데, 기본적으로는 1) 정적인 파일을 서빙하는 역할과 2) Web Application (WAS)에게 요청을 넘겨서 비즈니스 로직을 수행하는 역할을 한다. 이때 `Web Server`와 `Web Application` 간의 상호작용을 잘 처리할 수 있는 중간 지점이 필요한데 CGI는 이러한 인터페이스의 일종이라 생각하면 된다.

간단하게 CGI에 대해 설명하자면 특정 웹페이지를 실제 애플리케이션 프로그램과 연결하는 역할을 하는 것이다. 일반적으로 사용자에게 `HTTP Request`를 받았을 때, 이것을 적절하게 `환경변수 (Environment Variable)`로 만들어서 프로그램과 연결하는 역할을 하는 것이다. 근데, 딱 봐도 유저가 해당 요청을 특정 페이지로 보낼 때마다 새로운 프로세스가 생성되는 구조인 것 같은데, 당연하게도 요청이 조금만 많아져도 큰 문제가 될 것이라 생각되지 않는가? 해당 문제로 원래 CGI 자체는 지금은 사용되지 않는다. 다만 여러 방향으로 개선되어 사용되고 있다. (파이썬의 wsgi 등..)

파이썬에서 사용되는 방식에 대해 이야기하자면 보통 다음과 같은 구조로 이루어지게 된다.

```
웹서버 (NGINX) => WSGI 서버 (Gunicorn) => WSGI 애플리케이션 (장고) => 데이터베이스
ㄴ> 정적파일 (동적 요청 X 시)

- Nginx: Reverse Proxying, Buffering, Load Balancing 의 역할을 수행
- Gunicorn: Django로 작성된 Web Application에 HTTP 요청을 전달하는 역할의 WSGI Http Server
```

## Node.js가 프로덕션 레벨에서 리버스 프록시를 도입해야 하는 이유는 무엇일까.

Node.js 프로세스를 웹에 직접 노출해서는 안되며 대신 `Reverse Proxy` 뒤에 숨겨야 한다는 말을 자주 들을 수 있다. 왜 `Reverse Proxy`를 사용해야하는 것이 옳은가에 대해 알아보기 이전에 이 기술에 대해 먼저 알아보도록 하겠다.

### Reverse Proxy란 무엇인가?

리버스 프록시는 기본적으로 요청을 받고, 이를 다른 곳의 HTTP 서버로 전달한 뒤, 다시 응답을 수신하고 원래의 요청자에게 이 응답을 전달하는 "중개자"의 역할을 하는 특수한 유형의 웹 서버이다.

그러나 리버스 프록시는 일반적으로 요청자의 요청을 "그대로" 전달하지는 않는다. 오히려 정해진 룰에 맞게 수정해서 요청을 HTTP 서버에게 전달하는 경우가 일반적이다. 예를 들어, 리버스 프록시 서버가 `www.example.com:80`에 위치하고 `ex.example.com:8080`으로 포워딩해야하는 상황이라면, 원래의 `Host` 헤더를 포워딩하는 서버에 맞게 수정하고 요청을 전달하는 식으로 말이다. 또한 응답을 다시 전달하는 과정에서도 이와 같은 과정이 일어난다. 그뿐 아니라 `body`를 변형하는 일도 일반적으로 일어나는데 gzip compression을 응답에 적용하는 식이다. 또한 가장 흔한 케이스로는 내부 웹 서버가 HTTP로만 통신을 한다면 리버스 프록시를 통해 HTTPS를 지원하게 하는 방식이 있다.

또한 리버스 프록시는 들어오는 다수의 요청을 여러 개의 서버 인스턴스에 나눠 전달할 수 있다. 만약 리버스 프록시 `api.example.com` 이 노출되어 있다면, 이곳으로 들어오는 요청을 `api1.internal.example.org`, `api2` 등과 같은 곳으로 포워딩할 수 있다.

많은 종류의 리버스 프록시가 존재하지만 가장 유명한 것을 뽑자면 `Nginx`와 `HAProxy`를 뽑을 수 있다. 특히 Nginx가 일반적으로 많이 쓰이는 픽이라고 할 수 있다.

### 왜 Reverse Proxy를 써야하는가?

`SSL Termination`
SSL termination은 리버스 프록시를 이용해야 할 가장 유명한 이유 중 하나이다. 응용프로그램의 프로토콜을 `http`에서 `https`로 변경하는 것은 단순히 s를 하나 붙이는 것보다 많은 신경을 써야한다. 물론 노드 환경에서도 certificate file 들을 읽어와서 https 암호화를 직접 붙이는 식으로 만들 수도 있긴 하다.

그러나 이러한 과정을 직접 처리하고, SSL 인증서를 관리하는 것을 애플리케이션 레벨에서 수행하는 것은 귀찮은 일이다. 또한 인증서를 코드 레벨에서 처리하는 것은 귀찮을 뿐 아니라 보안 위험도 존재한다.

이러한 이유로 일방적으로 애플리케이션 내부가 아닌 리버스 프록시 내에서 SSL Termination을 수행하는 것이 좋다. `Let's Encrypt`의 `certbot` 같은 기술 덕분에 Nginx에서 인증서를 관리하는 것은 간단하게 cron job을 만드는 것만으로 해결될 수 있게 되었다. 이러한 방식은 비즈니스 로직에서 불필요한 코드를 덜어내는데 유용한 뿐만 아니라 편리함도 가져다 준다.

`gzip Compression`

## 🔗 참고문헌

- [참고](https://web.archive.org/web/20190821102906/https://medium.com/intrinsic/why-should-i-use-a-reverse-proxy-if-node-js-is-production-ready-5a079408b2ca)

## 🔗 연결문서
